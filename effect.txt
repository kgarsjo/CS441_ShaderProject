//++++++++++++++++++++++++++++++++++++++++++++
// ENBSeries effect file
// visit http://enbdev.com for updates
// Copyright (c) 2007-2012 Boris Vorontsov
//++++++++++++++++++++++++++++++++++++++++++++
//THIS IS HLSL FILE FORMAT FOR EXECUTING ADDITIONAL
//POST PROCESSING EFFECTS. MAKE THE COPY BEFORE CHANGING IT!

//kind of old black-white tv filter

//enable separation by 625 scanlines
//#define ESCANLINE


//+++++++++++++++++++++++++++++
//internal parameters, can be modified
//+++++++++++++++++++++++++++++
static const float PI = 3.14159265f;
float3 GrayFilter=float3(1.0, 0.7, 0.4);
float3 pink= {0.82, 0.01, 0.89};
float Brightness=0.8;
float ClampLow=0.03;
float ClampHigh=0.95;

float NoiseMixCurve=0.8;
float NoiseMixMultiplier=1.5;
float AdditiveNoiseFactor=0.2;
float MultiplicativeNoiseMin=0.5;
float MultiplicativeNoiseMax=1.5;

float BlurSamplingRange=1.0;//horizontal blur




//+++++++++++++++++++++++++++++
//external parameters, do not modify
//+++++++++++++++++++++++++++++
//keyboard controlled temporary variables (in some versions exists in the config file). Press and hold key 1,2,3...8 together with PageUp or PageDown to modify. By default all set to 1.0
float4	tempF1; //0,1,2,3
float4	tempF2; //5,6,7,8
float4	tempF3; //9,0
//x=generic timer in range 0..1, period of 16777216 ms (4.6 hours), w=frame time elapsed (in seconds)
float4	Timer;
float period= 4.0 / 10000.0;	// TODO validate later
//x=Width, y=1/Width, z=ScreenScaleY, w=1/ScreenScaleY
float4	ScreenSize;



//textures
texture2D texColor;
texture2D texNoise;

sampler2D SamplerColor = sampler_state
{
	Texture   = <texColor>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = NONE;//NONE;
	AddressU  = Clamp;
	AddressV  = Clamp;
	SRGBTexture=FALSE;
	MaxMipLevel=0;
	MipMapLodBias=0;
};

sampler2D SamplerNoise = sampler_state
{
	Texture   = <texNoise>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
	MipFilter = NONE;//NONE;
	AddressU  = Wrap;
	AddressV  = Wrap;
	SRGBTexture=FALSE;
	MaxMipLevel=0;
	MipMapLodBias=0;
};


struct VS_OUTPUT_POST
{
	float4 vpos  : POSITION;
	float2 txcoord : TEXCOORD0;
};

struct VS_INPUT_POST
{
	float3 pos  : POSITION;
	float2 txcoord : TEXCOORD0;
};

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Hue to RGB
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
float3 HUEtoRGB(in float H)
{
    float R = abs(H * 6.0 - 3.0) - 1.0;
    float G = 2.0 - abs(H * 6.0 - 2.0);
    float B = 2.0 - abs(H * 6.0 - 4.0);
    return saturate(float3(R,G,B));
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// RGB/C/V to Hue
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
float RGBCVtoHUE(in float3 RGB, in float C, in float V)
{
      float3 Delta = (V - RGB) / C;
      Delta.rgb -= Delta.brg;
      Delta.rgb += float3(2.0,4.0,6.0);
      Delta.brg = step(V, RGB) * Delta.brg;
      float H;
      H = max(Delta.r, max(Delta.g, Delta.b));
      return frac(H / 6.0);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Hue/Sat/Val to RGB
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
float3 HSVtoRGB(in float3 HSV)
{
    float3 RGB = HUEtoRGB(HSV.x);
    return ((RGB - 1) * HSV.y + 1) * HSV.z;
}
 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// RGB to Hue/Sat/Val
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
float3 RGBtoHSV(in float3 RGB)
{
    float3 HSV = 0.0;
    HSV.z = max(RGB.r, max(RGB.g, RGB.b));
    float M = min(RGB.r, min(RGB.g, RGB.b));
    float C = HSV.z - M;
    if (C != 0.0)
    {
      HSV.x = RGBCVtoHUE(RGB, C, HSV.z);
      HSV.y = C / HSV.z;
    }
    return HSV;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
VS_OUTPUT_POST VS_PostProcess(VS_INPUT_POST IN)
{
	VS_OUTPUT_POST OUT;

	float4 pos=float4(IN.pos.x,IN.pos.y,IN.pos.z,1.0);

	OUT.vpos=pos;
	OUT.txcoord.xy=IN.txcoord.xy;

	return OUT;
}




//1
float4 PS_ProcessColor(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	//#define CONTROL
	float4 res;
	float4 coord=0.0;
	coord.xy=IN.txcoord.xy;

	float4 origcolor=tex2Dlod(SamplerColor, coord);

	//black-white filter
	float4 orig= origcolor;
	origcolor.xyz=dot(origcolor.xyz, GrayFilter.xyz);
	
	// TODO Test lerp of RGB values (not HSV)
	
	// Convert to HSV and fetch Scale value
	float3 ohsv= RGBtoHSV(orig.xyz);
	float3 phsv= RGBtoHSV(pink);
	float scale= (Timer.x % period) / period * (2*PI);
	scale= abs( sin(scale) );
	
	// Interpolate Hue
	ohsv.x= lerp(ohsv.x, phsv.x, scale);
	//orig.xyz= HSVtoRGB(ohsv);
	orig.xyz= lerp(orig.xyz, pink, scale);
	
	// Average (?) Saturation
	ohsv.y= (ohsv.y + phsv.y) / 2;

	//scale
	origcolor.xyz*=Brightness;
	orig.xyz *= Brightness;
	
	//limit
	origcolor.xyz=clamp(origcolor.xyz, ClampLow, ClampHigh);
	orig.xyz= clamp(orig.xyz, ClampLow, ClampHigh);
	
	// Adjust RG values
	origcolor.xy *= 0.5;
	
	#ifndef CONTROL
		// Do non-control stuff here
		res.xyz= orig.xyz;
		res.w= 1.0;
		return res;
		
	#endif

	res.xyz= origcolor.xyz;
	res.w=1.0;
	return res;
}



//2
float4 PS_ProcessHorizontalBlur(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 res;
	float4 coord=0.0;

	coord.xy=IN.txcoord.xy;

	coord.w=0.0;

	int i=0;

	float4 tcol=0.0;
	float2 invscreensize=ScreenSize.y;
	float offset=-2.0;
	for (i=0; i<5; i++)
	{
		coord.x=IN.txcoord.x+offset*invscreensize*BlurSamplingRange;
		float4 ct=tex2Dlod(SamplerColor, coord);

		tcol+=ct;
		offset+=1.0;
	}
	res.xyz=tcol.xyz*0.2;

	res.w=1.0;
	return res;
}



//3
float4 PS_ProcessScanlines(VS_OUTPUT_POST IN, float2 vPos : VPOS) : COLOR
{
	float4 res;
	float4 coord=0.0;

	coord.xy=IN.txcoord.xy;
	float4 origcolor;
	coord.w=0.0;

	coord.y=floor(coord.y*625.0)*0.0016;//625 vertical lines
	res=tex2Dlod(SamplerColor, coord);

	res.w=1.0;
	return res;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
technique PostProcess
{
	pass P0
	{
		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessColor();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}

#ifdef ESCANLINE
technique PostProcess2
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessHorizontalBlur();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}

technique PostProcess3
{
	pass P0
	{

		VertexShader = compile vs_3_0 VS_PostProcess();
		PixelShader  = compile ps_3_0 PS_ProcessScanlines();

		DitherEnable=FALSE;
		ZEnable=FALSE;
		CullMode=NONE;
		ALPHATESTENABLE=FALSE;
		SEPARATEALPHABLENDENABLE=FALSE;
		AlphaBlendEnable=FALSE;
		StencilEnable=FALSE;
		FogEnable=FALSE;
		SRGBWRITEENABLE=FALSE;
	}
}
#endif //ESCANLINE


